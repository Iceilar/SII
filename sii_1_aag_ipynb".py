# -*- coding: utf-8 -*-
"""SII_1_AAG.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LUqgiiXNVzrnY7uN44meiz--WV9RaygE

#Домашняя работа № 1
---
"""

# Агупов А. Г.
# Гр. 4221
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras import utils
from tensorflow import keras

from google.colab import drive
drive.mount('/content/drive')

#Отображение первых 100 изображений из обучающей выборки

(x_train, y_train), (x_test, y_test) = mnist.load_data()

plt.figure(figsize=(10,5))
for i in range(100):
    plt.subplot(10,10,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.imshow(x_train[i], cmap=plt.cm.binary)

plt.show()

#Преобразование набора данных

print(y_train)

# Нормализация данных
x_train = x_train / 255
x_test = x_test / 255

# Преобразование выходных значений в векторы по категориям
y_train = keras.utils.to_categorical(y_train, 10)
y_test = keras.utils.to_categorical(y_test, 10)

# Преобразование размерности изображений
x_train = x_train.reshape(len(x_train),len(x_train[0])*len(x_train[1]))
x_test = x_test.reshape(len(x_test),len(x_test[0])*len(x_test[1]))

# Создание нейросети

# Создание последовательной модели
model = keras.Sequential()

# Добавление уровней сети
model.add(Dense(784, input_dim=784, activation="relu"))
model.add(Dense(10, activation="softmax"))

# Компиляция модели
model.compile(loss="categorical_crossentropy", optimizer="SGD", metrics=["accuracy"])
print(model.summary())

# Обучение нейросети

history = model.fit(x_train, y_train, batch_size=200, epochs=100,
                    validation_split=0.2, verbose=1)

# Тестирование на рукописных цифрах

from PIL import Image, ImageOps
prav_otv = [4, 7, 3, 1, 9, 0, 6, 2, 5, 8]

# Преобразование картинок для обработки нейронной сетью

import os
image_dir = '/content/drive/MyDrive/Colab Notebooks/Tcifirki/'

image_array = []
image_array_vis = []

for filename in os.listdir(image_dir):
      img_path = os.path.join(image_dir, filename)
      img = Image.open(img_path).convert('L')

      image_array_vis.append(Image.open(img_path))

      x = np.array(img)
      x = x.reshape(1, 784)
      x = 255 - x
      x = x / 255
      image_array.append(x)

print(f"Загружено {len(image_array)} изображений")

# Вывод рукописных картинок
plt.figure(figsize=(10,10))
for i in range(len(image_array)):
    plt.subplot(5,5,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.imshow(image_array_vis[i], cmap=plt.cm.binary)

plt.show()

otv = []
for x in range(len(image_array)):
  # Распознавание
  otv.append(np.argmax(model.predict(image_array[x])))

# Результат распознавания
print()
zip(otv, prav_otv)

for i in range(len(otv)):
    print(f"Картинка № {i} - полученный ответ = {otv[i]} / правильный ответ = {prav_otv[i]}")

plt.figure(figsize=(10,10))
for i in range(len(image_array)):
    plt.subplot(5,5,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.imshow(image_array_vis[i], cmap=plt.cm.binary)

plt.show()

"""##Выводы по полученной модели

Полученная модель в большинстве случаев делает правильные прогноз, но у неё возникают проблемы если:
* размер цифры больше чем на тренировочной выборке, т.е. она касается границ изображения (пример "0" и "9")
* при распознавании цифр, написанных специфическим подчерком (пример "7")
"""